参考官网给出的例子，然后写了一个小demo，开始对这个demo的启动流程开始分析：
1.按照FirstNettyServer中，我们首先创建了一个boss线程组和一个work线程组，默认情况下我们在初始化NioEventLoopGroup，并且不设置它构造方法呢中的线程
数量，默认是可以通过查看MultithreadEventLoopGroup中的DEFAULT_EVENT_LOOP_THREADS可以看到，如果参数为０（也是就是不设置的情况下），数量为
NettyRuntime.availableProcessors() * 2，换句话说也就是cpu核数*2
2.现在出现几个问题，1)为什么我们要创建两个线程组。2)如果简单了解过netty的，应该知道，我们在创建boss线程，一般设置的thread的数量为１，如果设置为其他
数量会有什么影响呢？以及boss线程组和work线程组又是干什么的呢？
我们首先进入serverBootstrap的bind方法，来一层一层进入，最终我们会找到AbstractBootstrap中的doBind方法，它里面有一个initAndRegister,
我们进入之后会看到里面的方法内容大致是1)创建NioServerSocketChannel(可以打断点查看).2)对channel进行初始化.3)注册到group中.4)返回channelFuture
通过在AbstractBootstrap中的initAndRegister的方法中的的config().group().register(channel),来进行分析。我们进入group方法中，看到的是
调用bootstrap的group方法，换句话说返回的是bossGroup(boss线程组)。综上所述，我们是要将NioServerSocketChannel注册到boss线程组。
我们继续，看register方法，因为我们创建的是bossGroup实际上是NioEventLoopGroup, 所以进入该group的register方法。实际进入
MultithreadLoopGroup中的register方法，内部是调用next().register(channel).来看next()方法，继续进入可以看到MultithreadEventExecutorGroup
中的next方法，内部实现是chooser.next()，继续看chooser是个什么鬼，可以看到MultithreadEventExecutorGroup内部的构造方法中的chooserFactory
的newChooser(children)方法创建的chooser,深入newChooser.实际使用的是DefaultEventExecutorChooserFactory的newChooser方法，内部逻辑是
判断group的线程数是不是２的次幂，返回相应的chooser,到目前好像并没有什么卵用。返回到刚才的问题，调用next方法实际调用相应chooser
类中的next方法，而chooser分为两种，PowerOfTwoEventExecutorChooser和GenericEventExecutorChooser。然而，next方法返回的是EventExcutors中的
一个EventExecutor,现在我们来看EventExecutor数组里面数据是啥。在MultithreadEventExecutorGroup中对该数组进行创建和初始化。可以看到
是通过newChild对数组数据进行填充，而newChild方法实际使用的是NioEventLoopGroup中的newChild，返回的是NioEventLoop，也就是说EventExcutors
里面存储的是NioEventLoop.返回刚才的点上，chooser.next()返回的是NioEventLoop，调用NioEventLoop（实际是个单线程）的register.
综上所述，对于bossGroup方法会创建NioServerChannel，并且将该channel注册到boss线程组的一个线程上，因为chooser调用的next方法，返回的
是EventExcutors中的一个值，也即是单个NioEventLoop.

